final FAILURE = '#FF0000'

def keepgoing = true
def buildTest = JOB_NAME.contains("BuildTest")
def branchCodeName = 'focal'


def getPreviousStatus(build) {
    if (build == null) {
        return 'ABORTED'
    }
    if (build.result != null && build.result != 'ABORTED') {
        return build.result
    }
    return getPreviousStatus(build.getPreviousBuild())
}

def notifyStatusChange(buildStatus) {
    final UNKNOWN  = '#0000FF'
    final SUCCESS  = '#00FF00'
    final UNSTABLE = '#FFFF00'

    def color = UNKNOWN

    switch (buildStatus) {
        case 'SUCCESS':
            color = SUCCESS
            break

        case 'UNSTABLE':
            color = UNSTABLE
            break
    }

    // Notification already happened if 'FAILURE'. We don't care about canceled builds
    def prevStatus = getPreviousStatus(currentBuild.getPreviousBuild())
    if (buildStatus != prevStatus && buildStatus != 'FAILURE' && buildStatus != 'ABORTED' && prevStatus != 'ABORTED') {
        echo "Status notifcation (previous, current): ${prevStatus}, ${buildStatus}"
        sendNotification(color, buildStatus)
    }
}

def sendNotification(color, buildStatus) {
    slackSend(color: color, message: buildStatus + ": ${env.JOB_NAME} [${env.BUILD_NUMBER}] (<${env.BUILD_URL}|open>)")
}

pipeline {
    agent { label "UPSTREAM-20.04" }

    options {
        buildDiscarder(logRotator(daysToKeepStr: '30', artifactNumToKeepStr: '2'))
        disableConcurrentBuilds()
    }

    parameters {
        string(defaultValue: '/scratch/www/local/ceph', description: 'Path to package repo server ' +
                'branch added automatically', name: 'WWW_ROOT')
    }

    environment {
	JAVA_HOME = "/usr/lib/jvm/java-11-openjdk-amd64"
	JAWT_INCLUDE_PATH = "/usr/lib/jvm/java-11-openjdk-amd64/include/jawt.h"

	// XXX: 
	// The target Ubuntu release is required for packaging.
	// If not set then the generated repo will be named $(lsb_release -sc)
	// which for most build machines is "bionic", but this branch is
	// targeted for "focal"
	//
	def UBUNTU_CODENAME = sh(script: "lsb_release -sc", returnStdout: true).trim()
	def VERSION = sh(script: "git describe", returnStdout: true).trim()

        RELEASE_NAME = "${env.BRANCH_NAME}-${VERSION}-${env.BUILD_NUMBER}"
	SPECTRA_INFO = "${env.RELEASE_NAME}.build"

	WORK_DIR = "/tmp/ceph_work/${env.BRANCH_NAME}"

	// The build deposits packages and repo under:
	BUILD_ARTIFACT_DIR = "${env.WORK_DIR}/Ubuntu"

	// Artifacts that comprise the apt repo relative
	// to BUILD_ARTIFACT_DIR:
	ARTIFACT_LIST = "${UBUNTU_CODENAME} conf db dists pool ${env.SPECTRA_INFO}"

	// Distribute the generated reopo to:
        WWW_DIST_DIR = "${params.WWW_ROOT}/${env.BRANCH_NAME}"
	WWW_DIST_REL_DIR = "${env.WWW_DIST_DIR}/${env.RELEASE_NAME}"
        WWW_TOKEEP = "11"
    }
    stages {
        stage('CheckCause') {
            when {
                expression {
                    buildTest &&
                    "${currentBuild.getBuildCauses('jenkins.branch.BranchEventCause').size()}" != "0"
                }
            }
            steps {
                script {
                    currentBuild.result = 'ABORTED'
                    keepgoing = false
                    echo "Skipping build caused by: ${currentBuild.getBuildCauses()[0].shortDescription}"
                }
            }
        }

        stage('Clean') {
            when { expression { keepgoing } }
            steps {
                sh "sudo rm -fr ${env.WORK_DIR}/*"
		sh "sudo git clean -xdf"
                sh "sudo mkdir -p ${env.WORK_DIR}/tmp"
                sh "sudo chmod -R 777 ${env.WORK_DIR}"
            }
        }
	
        stage('OSversion') {
            when {
                expression {
                   return '${UBUNTU_CODENAME}' == '${branchCodeName}'
                }
            }
            steps {
                    error "build machine running  '${UBUNTU_CODENAME}', but require '${branchCodeName}'"
            }
        }

        stage('Dependencies') {
            when { expression { keepgoing } }
            steps {
                sh "./install-deps.sh"
            }
        }

        stage('BuildCeph') {
            when { expression { keepgoing } }
            steps {
                sh "TMPDIR='${env.WORK_DIR}/tmp' JAVA_HOME='${env.JAVA_HOME}' " +
	           "JAWT_INCLUDE_PATH='${JAWT_INCLUDE_PATH}' " +
                   "./make-debs.sh '${env.WORK_DIR}'"
            }
        }

	stage('BuildInfo') {
            when { expression { keepgoing } }
            steps {
                sh "./spectra-buildinfo.sh '{env.BUILD_ARTIFACT_DIR}/${env.SPECTRA_INFO}' '${env.BRANCH_NAME}' '${VERSION}' '${env.BUILD_NUMBER}' '${env.ARTIFACT_LIST}'"
            }
        }

        stage('Archive') {
            when { expression { keepgoing && !buildTest } }
            steps {
                sh "sudo mkdir -pm 777 ${env.WWW_DIST_DIR}/ || true"
                sh "sudo mkdir -m 777 ${env.WWW_DIST_REL_DIR}"
                sh "sudo tar -cf - -C ${env.WORK_DIR} ${env.ARTIFACT_LIST} | tar -xvf - -C ${env.WWW_DIST_REL_DIR}"

                dir("${WWW_DST_DIR}") {
                    sh "ln -sf ${env.RELEASE_NAME} latest"
                    sh "echo ${env.RELEASE_NAME} > latest.txt"
                    sh "sudo chmod 666 latest.txt"
                }
                sh "sudo rm -fr ${env.WWW_DST_DIR}@tmp"
            }
        }

        stage('ReleasePrune') {
            when { expression { keepgoing && !buildTest } }
            steps {
                sh "sudo ls -1t ${env.WWWW_DST_DIR}/ceph-* | tail -n +${env.WWW_TOKEEP} | xargs rm -fr"
            }
        }


        stage('PostClean') {
            when { expression { keepgoing } }
            steps {
                sh "sudo rm -fr ${env.WORK_DIR}/*"
            }
        }
    }

    post {
        success {
            notifyStatusChange(currentBuild.currentResult)
        }
        failure {
            sendNotification(FAILURE, currentBuild.currentResult)
        }
    }
}
