final FAILURE = '#FF0000'

def keepgoing = true
def buildTest = JOB_NAME.contains("BuildTest")
def branchCodeName = 'focal'


def getPreviousStatus(build) {
    if (build == null) {
        return 'ABORTED'
    }
    if (build.result != null && build.result != 'ABORTED') {
        return build.result
    }
    return getPreviousStatus(build.getPreviousBuild())
}

def notifyStatusChange(buildStatus) {
    final UNKNOWN  = '#0000FF'
    final SUCCESS  = '#00FF00'
    final UNSTABLE = '#FFFF00'

    def color = UNKNOWN

    switch (buildStatus) {
        case 'SUCCESS':
            color = SUCCESS
            break

        case 'UNSTABLE':
            color = UNSTABLE
            break
    }

    // Notification already happened if 'FAILURE'. We don't care about canceled builds
    def prevStatus = getPreviousStatus(currentBuild.getPreviousBuild())
    if (buildStatus != prevStatus && buildStatus != 'FAILURE' && buildStatus != 'ABORTED' && prevStatus != 'ABORTED') {
        echo "Status notifcation (previous, current): ${prevStatus}, ${buildStatus}"
        sendNotification(color, buildStatus)
    }
}

def sendNotification(color, buildStatus) {
    slackSend(color: color, message: buildStatus + ": ${env.JOB_NAME} [${env.BUILD_NUMBER}] (<${env.BUILD_URL}|open>)")
}

pipeline {
    agent { label "UPSTREAM" }

    options {
        buildDiscarder(logRotator(daysToKeepStr: '30', artifactNumToKeepStr: '2'))
        disableConcurrentBuilds()
    }

    parameters {
        string(defaultValue: '/scratch/packages/ceph', description: 'Path to archive packages, branch added ' +
                'automatically', name: 'BUILD_PKG_ROOT')
    }

    environment {
	WORK_DIR = "/tmp/ceph_work/${env.BRANCH_NAME}_branch"
	JAVA_HOME = "/usr/lib/jvm/java-11-openjdk-amd64"
	JAWT_INCLUDE_PATH = "/usr/lib/jvm/java-11-openjdk-amd64/include/jawt.h"

	// XXX: 
	// The target Ubuntu release is required for packaging.
	// If not set then the generated repo will be named $(lsb_release -sc)
	// which for most build machines is "bionic", but this branch is
	// targeted for "focal"
	//
	def UBUNTU_CODENAME = sh(script: "lsb_release -sc", returnStdout: true).trim()
	def VERSION = sh(script: "git describe", returnStdout: true).trim()

	ARTIFACTS_NAME = "${env.BRANCH_NAME}-${VERSION}-${env.BUILD_NUMBER}"
	ARTIFACTS_SRC_DIR = "${env.WORK_DIR}/Ubuntu"
	ARTIFACTS_DST_DIR = "${params.BUILD_PKG_ROOT}/${env.BRANCH_NAME}"
	ARTIFACTS_TAR = "${env.ARTIFACTS_DST_DIR}/${env.ARTIFACTS_NAME}.tgz"

	SPECTRA_INFO = "${env.ARTIFACTS_NAME}.build"
	SPECTRA_INFO_PATH = "${env.ARTIFACTS_SRC_DIR}/${env.SPECTRA_INFO}"
	ARTIFACTS_LIST = "${UBUNTU_CODENAME} conf db dists pool ${env.SPECTRA_INFO}"
    }
    stages {
        stage('CheckCause') {
            when {
                expression {
                    buildTest &&
                    "${currentBuild.getBuildCauses('jenkins.branch.BranchEventCause').size()}" != "0"
                }
            }
            steps {
                script {
                    currentBuild.result = 'ABORTED'
                    keepgoing = false
                    echo "Skipping build caused by: ${currentBuild.getBuildCauses()[0].shortDescription}"
                }
            }
        }

        stage('Clean') {
            when { expression { keepgoing } }
            steps {
                sh "sudo rm -fr ${env.WORK_DIR}/*"
		sh "sudo git clean -xdf"
                sh "sudo mkdir -p ${env.WORK_DIR}/tmp"
                sh "sudo chmod -R 777 ${env.WORK_DIR}"
            }
        }

        stage('Dependencies') {
            when { expression { keepgoing } }
            steps {
                if ("${UBUNTU_CODENAME}" != "${branchCodeName}") {
                    error "build machine running  '${UBUNTU_CODENAME}', but require '${branchCodeName}'"
                }
                sh "./install-deps.sh"
            }
        }

        stage('Build Ceph') {
            when { expression { keepgoing } }
            steps {
                sh "TMPDIR='${env.WORK_DIR}/tmp' JAVA_HOME='${env.JAVA_HOME}' " +
	           "JAWT_INCLUDE_PATH='${JAWT_INCLUDE_PATH}' " +
                   "./make-debs.sh '${env.WORK_DIR}'"
            }
        }

	stage('Build Info') {
            when { expression { keepgoing } }
            steps {
                sh "./spectra-buildinfo.sh '${env.SPECTRA_INFO_PATH}' '${env.BRANCH_NAME}' '${VERSION}' '${env.BUILD_NUMBER}' '${env.ARTIFACTS_LIST}'"
            }
        }

        stage('Archive') {
            when { expression { keepgoing && !buildTest } }
            steps {
                sh "sudo mkdir -pm 777 ${env.ARTIFACTS_DST_DIR}/ || true"
		sh "sudo tar -czvf ${env.ARTIFACTS_TAR} -C ${env.ARTIFACTS_SRC_DIR} ${env.ARTIFACTS_LIST}"
		sh "sudo chmod 666 ${env.ARTIFACTS_TAR}"
            }
        }

        stage('PostClean') {
            when { expression { keepgoing } }
            steps {
                sh "sudo rm -fr ${env.WORK_DIR}/*"
            }
        }
    }

    post {
        success {
            notifyStatusChange(currentBuild.currentResult)
        }
        failure {
            sendNotification(FAILURE, currentBuild.currentResult)
        }
    }
}
