final FAILURE = '#FF0000'

def keepgoing = true
def buildTest = JOB_NAME.contains("BuildTest")
def signTest = params.PRODUCTION

def getPreviousStatus(build) {
    if (build == null) {
        return 'ABORTED'
    }
    if (build.result != null && build.result != 'ABORTED') {
        return build.result
    }
    return getPreviousStatus(build.getPreviousBuild())
}

def notifyStatusChange(buildStatus) {
    final UNKNOWN  = '#0000FF'
    final SUCCESS  = '#00FF00'
    final UNSTABLE = '#FFFF00'

    def color = UNKNOWN

    switch (buildStatus) {
        case 'SUCCESS':
            color = SUCCESS
            break

        case 'UNSTABLE':
            color = UNSTABLE
            break
    }

    // Notification already happened if 'FAILURE'. We don't care about canceled builds
    def prevStatus = getPreviousStatus(currentBuild.getPreviousBuild())
    if (buildStatus != prevStatus && buildStatus != 'FAILURE' && buildStatus != 'ABORTED' && prevStatus != 'ABORTED') {
        echo "Status notifcation (previous, current): ${prevStatus}, ${buildStatus}"
        sendNotification(color, buildStatus)
    }
}

def sendNotification(color, buildStatus) {
    slackSend(color: color, message: buildStatus + ": ${env.JOB_NAME} [${env.BUILD_NUMBER}] (<${env.BUILD_URL}|open>)")
}

pipeline {
    agent { label "UPSTREAM" }

    // START_JENKINSFILE_PIPELINE_SPECIFIC
    // Note: see bin/jf_to_jbt
    //
    options {
        buildDiscarder(logRotator(daysToKeepStr: '30', artifactNumToKeepStr: '2'))
        disableConcurrentBuilds()
    }
    // END_JENKINSFILE_PIPELINE_SPECIFIC

    parameters {
        string(defaultValue: '/scratch/packages/ceph', description: 'Path to archive packages, branch added ' +
                'automatically', name: 'BUILD_PKG_ROOT')
    }
    environment {
	CEPH_BRANCH = "${env.BRANCH_NAME}"
	WORK_DIR = "/tmp/ceph_work/${env.BRANCH_NAME}_branch"
	JAVA_HOME = "/usr/lib/jvm/java-11-openjdk-amd64"
	JAWT_INCLUDE_PATH = "/usr/lib/jvm/java-11-openjdk-amd64/include/jawt.h"
	ARTIFACTS_DIR = "${params.BUILD_IMG_ROOT}/${env.BRANCH_NAME}"
	ARTIFACTS = "${env.ARTIFACTS_DIR}/ceph_deb_repo.${env.BUILD_NUMBER}.tgz"
    }
    stages {
        stage('CheckCause') {
            when {
                expression {
                    buildTest &&
                    "${currentBuild.getBuildCauses('jenkins.branch.BranchEventCause').size()}" != "0"
                }
            }
            steps {
                script {
                    currentBuild.result = 'ABORTED'
                    keepgoing = false
                    echo "Skipping build caused by: ${currentBuild.getBuildCauses()[0].shortDescription}"
                }
            }
        }
        stage('Clean') {
            when { expression { keepgoing } }
            steps {
                sh "sudo rm -fr ${env.WORK_DIR}/*"
		sh "sudo git clean -xdf"
                sh "sudo mkdir -p ${env.WORK_DIR}"
                sh "sudo chmod 777 ${env.WORK_DIR}"
            }
        }
        stage('Dependencies') {
            when { expression { keepgoing } }
            steps {
                sh "./install-deps.sh"
            }
        }
        stage('Build Ceph') {
            when { expression { keepgoing } }
            steps {
                sh "TMPDIR='${env.WORK_DIR}/tmp' JAVA_HOME='${env.JAVA_HOME}' " +
	           "JAWT_INCLUDE_PATH='${JAWT_INCLUDE_PATH}' " +
                   "./make-debs.sh '${env.WORK_DIR}'"
            }
        }
        stage('Archive') {
            when { expression { keepgoing && !buildTest } }
            steps {
                sh "mkdir -pm 777 ${env.ARTIFACTS_DIR}/ || true"
		sh "sudo tar -czvf ${env.ARTIFACTS} -C ${env.WORK_DIR}/Ubuntu bionic conf db dists pool"
		sh "chmod 666 ${env.ARTIFACTS}"
            }
        }
    }
    post {
        success {
            notifyStatusChange(currentBuild.currentResult)
        }
        failure {
            sendNotification(FAILURE, currentBuild.currentResult)
        }
    }
}
